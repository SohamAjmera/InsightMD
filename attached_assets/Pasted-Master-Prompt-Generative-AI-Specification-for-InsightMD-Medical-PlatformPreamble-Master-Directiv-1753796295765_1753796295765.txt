Master Prompt: Generative AI Specification for "InsightMD" Medical PlatformPreamble: Master Directive for "InsightMD" AI Application GenerationYou are an expert team of full-stack developers, security engineers, and UI/UX designers. Your mission is to build a complete, production-ready, and HIPAA-compliant AI-powered medical insights and telehealth platform named "InsightMD". You will generate the entire codebase based on the detailed specifications below. The application must be fully functional, secure, and optimized for a compelling hackathon demonstration.Core TechnologiesThe application will be built exclusively with the following technology stack. Adherence to this stack is mandatory.Frontend: React with Next.js (using TypeScript and the App Router).Backend: Node.js with the Express.js framework (using TypeScript).Database: Supabase, utilizing its PostgreSQL database, Authentication, and Storage services.AI/ML: The Google Gemini API, specifically a multimodal model capable of advanced image and text analysis (e.g., gemini-pro-vision or a more recent, capable version).1Real-Time Video: The Zoom Video SDK for all telehealth functionalities.Code Generation ProtocolGenerate the entire application source code in a modular, well-documented, and clean format. Provide separate, clearly named files for each component, service, API route, and utility function. The file structure should be logical and follow established best practices for Next.js and Node.js/Express applications. Finally, generate a comprehensive README.md file that includes detailed setup instructions, environment variable requirements, database seeding commands, and deployment guidance.Section 1: Core Application Blueprint and User Experience (UX) FlowNarrative OverviewThe primary purpose of "InsightMD" is to empower patients by providing them with accessible, AI-driven analysis of their personal medical data, and to seamlessly connect them with qualified medical specialists for professional consultation. The platform is an informational tool designed to augment, not replace, traditional medical advice. The user journey is designed to be intuitive, secure, and reassuring, guiding the user from data upload to actionable insights and professional connection.User Journey MappingThe application flow must follow this precise sequence, as detailed in the project flowchart.Landing and Onboarding: A user, whether new or returning, first arrives at the Home/Landing Page. This page must clearly and concisely communicate the tool's value proposition: "AI-powered medical insight generator." It will feature a professional and clean design, with prominent calls-to-action for "Register" and "Log In." Crucially, the footer of every page, starting with this one, must contain persistent links to the Privacy Policy and a comprehensive Medical Disclaimer.Authentication: The user initiates the registration or login process. This flow must be secure and user-friendly, leading directly to the main application upon success.Profile and Dashboard: After a successful first login, the user is prompted to complete a basic profile. Subsequently, they land on their personal dashboard. This dashboard serves as the central hub of their experience, offering a high-level overview of their activity, including a list of past uploads, links to generated reports, and a schedule of upcoming appointments.Data Ingestion: From the dashboard, the user navigates to a dedicated "Upload Page." Here, they can upload various medical documents, such as diagnostic imaging files and lab reports.AI Processing and Visualization: Once files are successfully uploaded, the backend automatically triggers the AI analysis pipeline. The user interface must provide clear feedback on this process, displaying progress indicators for both the analysis and the generation of the final report. Upon completion, the user can access the results, which include an interactive 2D/3D visualization of their scans and a detailed, AI-generated analytical report.Connecting with Specialists: The AI report includes a recommendation for a relevant specialist type. Based on this, the system presents a list of matching doctors. The user can browse specialist profiles, view their credentials and availability, and proceed to book a video consultation. The entire booking, scheduling, and payment process is handled within the platform.Telehealth Consultation: At the scheduled time, both the user and the specialist join a secure, high-quality video consultation session hosted directly within the "InsightMD" application. This avoids redirecting users to external applications, ensuring a seamless and professional experience.Feedback and Support: Following any interaction, the user has the opportunity to submit feedback on their experience. For general queries, an AI-powered support chatbot is available to provide assistance.Section 2: Detailed Feature Implementation MandatesThis section deconstructs each module of the application into granular, actionable tasks with specific technical requirements.2.1 User Authentication, Onboarding, and Profile ManagementA secure and robust user management system is the foundation of the application's trust and compliance posture.Functional Requirements:Authentication Provider: Implement the entire authentication system using Supabase Auth. This provides a secure, scalable, and well-integrated solution out of the box.3Registration: The sign-up process will require an email and a strong password. Implement client-side and server-side validation to enforce password complexity rules (e.g., minimum length, character types).Login and Security: The login flow must be secure. It is mandatory to implement Multi-Factor Authentication (MFA) as an available option for users to enable. This is a critical technical safeguard under HIPAA to ensure that a person seeking access to Protected Health Information (PHI) is the one claimed.4Session Management: Utilize secure, HTTP-only cookies for session management to mitigate cross-site scripting (XSS) attacks. Supabase's server-side auth helpers for Next.js should be used to manage this.Profile Setup: After the initial registration, direct the user to a "Complete Profile Setup" page to collect non-PHI data such as their full name and an optional avatar URL.User Dashboard: This will be the main authenticated view. It must fetch and display a summary of the user's medical_uploads, ai_reports, and appointments from the database.2.2 Medical Data Ingestion and ManagementThe process for handling sensitive user data must be secure, efficient, and transparent.Functional Requirements:Upload Component: Create a modern, drag-and-drop file uploader component on the "Upload Page."Supported Formats: The uploader must be configured to accept files with the following extensions: .dcm (DICOM), .nii (NIfTI), .jpg, .jpeg, .png, and .pdf. This covers the primary medical imaging and report formats.File Handling and Storage: All uploaded files constitute PHI and must be handled with extreme care. Files must be uploaded directly from the client to a dedicated, private bucket in Supabase Storage. This bucket must have strict access policies configured, allowing uploads only by authenticated users and downloads only through controlled backend logic.Upload Process Logic:The user selects one or more files in the frontend component.The frontend validates the file type and size against predefined limits.The file is uploaded securely to the Supabase Storage bucket.Upon a successful upload, the frontend makes an API call to the backend. This call triggers the creation of a new record in the medical_uploads database table, associating the user_id with the file_path in storage.This API endpoint will also trigger a background job to begin the AI analysis. The frontend must display clear progress indicators for each uploaded file, showing states like "Uploading," "Processing," and "Complete".72.3 AI-Powered 2D-to-3D Medical Image VisualizationThis feature is the visual centerpiece of the application and must deliver a high-impact, interactive experience.Technical Mandate: The visualization component must be built using the Cornerstone.js library, specifically the modern Cornerstone3D suite, which is designed for high-performance, GPU-accelerated medical image display in the browser.8 This component will be integrated into the Next.js frontend. The research indicates that while other libraries exist, Cornerstone3D is a robust, standards-compliant, and extensible choice for this specific task.10Functional Requirements:DICOM Loading: The component must use @cornerstonejs/dicom-image-loader to fetch and parse DICOM series (stacks of 2D images) from the secure URLs provided by the backend.3D Reconstruction: It must process the 2D DICOM slices and render them as an interactive 3D volume. This capability to convert 2D scans into 3D models is a core requirement and a key element for patient education and understanding.13Interactive Tools: The viewer must not be static. It is mandatory to enable a suite of interactive tools from @cornerstonejs/tools to allow for manipulation of the visualization. At a minimum, this must include: PanTool, ZoomTool, WindowLevelTool (for adjusting contrast), StackScrollMouseWheelTool (for scrolling through 2D slices), and CrosshairsTool (for anatomical reference).8Downloadable Visualizations: Implement a function that allows the user to capture the current view of the viewport (whether 2D or 3D) and download it as a PNG file.The Interactive AI-Visualization Loop:A static 3D model is impressive, but a dynamic model that visually corroborates the AI's findings creates a far more powerful and compelling user experience, especially for a hackathon demonstration. This requires a seamless feedback loop between the AI analysis and the visual representation.Implementation: The AI-generated report (detailed in Section 2.4) will include spatial coordinates for any identified regions of interest (ROIs). The frontend component that houses the Cornerstone.js viewer must be designed to accept these coordinates as props. When these props are received, the component will use Cornerstone.js's annotation tools (e.g., RectangleROITool or a similar overlay) to programmatically draw a bounding box or highlight the specific area on both the 2D slices and the 3D model. This creates an immediate, intuitive connection for the user: the AI report says "potential anomaly found here," and the viewer shows exactly where "here" is. This demonstrates a deep integration of the AI and visualization layers.2.4 AI-Powered Diagnostic Assistance Report GenerationThis is the core intelligence engine of "InsightMD". Its implementation requires careful prompt engineering, secure backend processing, and a strong emphasis on responsible AI practices.Technical Mandate: All analysis and report generation will be powered by the Google Gemini API. The Node.js backend will serve as the sole intermediary, managing all requests to and responses from the Gemini API. Exposing the API key to the client is strictly forbidden.Functional Requirements:Multimodal Analysis: The backend will create a service that retrieves an uploaded file (image or PDF) from Supabase Storage. It will then prepare and send this data to a multimodal Gemini model (e.g., gemini-pro-vision) for analysis.2 For images, this will involve passing the image data directly; for PDFs, it will involve text extraction followed by analysis.Structured Prompting: The prompt sent to the Gemini API is the most critical element of this feature. It must be engineered to request a structured JSON response. This is non-negotiable, as it allows the backend to programmatically parse, save, and display the results without unreliable string manipulation. The prompt must instruct the model to act as a "radiology assistant" or "medical text summarizer" and provide its output according to a predefined schema.Report Content: The structured JSON response, which will be stored in the database, must contain the following fields:summary: A concise, plain-language summary of the findings, suitable for a non-medical audience.potential_observations: An array of objects detailing potential anomalies or notable findings.roi_coordinates: An array of objects containing spatial coordinates (x, y, z, width, height) for each observation, for use by the Cornerstone.js viewer.suggested_next_steps: A list of potential follow-up actions or tests.recommended_specialist: A string containing the type of medical specialist most relevant to the findings (e.g., "Neurologist," "Oncologist," "Cardiologist").PDF Report Generation: The backend must take the structured JSON data and format it into a professional, cleanly designed, and downloadable PDF report. This report should include the user's name, the date of analysis, and all the information from the JSON object.Proactive Risk Mitigation and Responsible AI:The application's greatest liability is the potential for it to be misinterpreted as a definitive diagnostic tool, which it is not. This presents significant legal and ethical risks that must be addressed at the architectural level.16Implementation:Prompt Engineering for Safety: Every prompt sent to the Gemini API must include a clear meta-instruction: "Your role is to provide informational observations for review by a qualified medical professional. You must not provide a definitive diagnosis. Frame all outputs as possibilities or suggestions. Emphasize that this tool is not a substitute for professional medical advice."Backend Disclaimer Injection: Create a dedicated backend module whose sole purpose is to append a standardized, legally-vetted medical disclaimer to every AI-generated report before it is saved to the ai_reports table or sent to the frontend. This ensures the disclaimer is a non-negotiable, immutable part of every analysis.Prominent Frontend Display: In the UI, this disclaimer must be displayed prominently at the top of the report page, in a clear and readable font. It must not be hidden in a collapsed section or a small-print footer.2.5 Intelligent Specialist Matching and Telemedicine PlatformThis feature closes the loop by connecting AI-driven insights to human expertise.Functional Requirements:Specialist Matching: The backend will implement an API endpoint that takes the recommended_specialist string from a user's AI report and queries the specialists database table to return a list of matching doctors.Specialist Profiles: The frontend will display these results, allowing users to click through to detailed profile pages for each specialist, showing their photo, credentials, specialty, and consultation fee.Booking and Scheduling: Implement a complete appointment booking system. Users must be able to view a specialist's availability (e.g., in a calendar interface) and schedule a time slot.Payment Integration: Integrate a secure payment gateway, such as Stripe, to handle the collection of consultation fees at the time of booking.Managed Video SDK for Telemedicine:Building a secure, scalable, and HIPAA-compliant real-time video platform from scratch using raw WebRTC is an enormous engineering challenge, far outside the scope of an MVP or hackathon project.18 A managed SDK provides a professional-grade solution with a fraction of the development effort.Implementation: Integrate the Zoom Video SDK. Zoom is a globally recognized and trusted brand in video communications, and its SDK is robust, well-documented, and now leverages WebRTC for improved browser performance and compatibility.20 The backend will use the Zoom REST API to programmatically create a unique, secure meeting session for each confirmed appointment, storing the session details in the appointments table. The frontend will use the Zoom Web SDK to embed the video client directly into a dedicated page within the "InsightMD" application. This provides a seamless, in-app telehealth experience without redirecting the user to the Zoom website or desktop client.2.6 User Feedback, Support, and Engagement SystemThese features enhance user trust and provide valuable data for future improvements.Functional Requirements:Feedback Form: Create a simple but functional form that allows users to submit feedback, bug reports, and testimonials. These submissions will be stored in a dedicated database table.AI Support Chatbot: Implement an AI-powered support chatbot using the Gemini API. This chatbot will be trained on a knowledge base of FAQs about the application. Its purpose is to answer non-medical questions regarding billing, feature usage, and troubleshooting. It must be explicitly programmed with a guardrail to refuse to answer any medical questions and, in such cases, must respond with a message directing the user to book a consultation with a specialist.Multi-language Support: The application UI should be designed with internationalization (i18n) in mind. Key text elements and the AI-generated report summaries should be translatable into multiple languages.Text-to-Speech: For enhanced accessibility, include a feature that allows the AI report summary to be read aloud to the user, using the browser's native Web Speech API.Section 3: Technical Architecture and Non-Functional RequirementsThis section defines the foundational rules, structures, and compliance mandates that govern the entire application.3.1 Frontend Architecture (React/Next.js)Framework: Utilize Next.js 14+ with the App Router. This choice enables powerful features like Server Components, Server-Side Rendering (SSR), and Static Site Generation (SSG), which lead to better performance, SEO, and a more organized codebase.Language: Mandate the use of TypeScript for all frontend code to ensure type safety and improve developer experience.State Management: For managing global application state, such as user authentication status and dashboard data, implement a modern state management library. Zustand is recommended for its simplicity and minimal boilerplate, but Redux Toolkit is also an acceptable alternative.UI/UX: Employ a modern UI component library to ensure a polished and consistent visual identity. Shadcn/ui is highly recommended for its accessible, unstyled components that can be easily customized. The design must be fully responsive, providing an excellent user experience on both desktop and mobile devices.Accessibility: The application must adhere to Web Content Accessibility Guidelines (WCAG) 2.1 Level AA. This includes proper use of semantic HTML, ARIA attributes where necessary, keyboard navigability, and sufficient color contrast.3.2 Backend Architecture (Node.js/Express.js)Framework: The backend API will be built with Express.js running on Node.js.Language: Mandate the use of TypeScript for all backend code.API Design: Design and implement a secure, stateless RESTful API. Every API endpoint that creates, retrieves, updates, or deletes PHI must be protected and require a valid, verified authentication token from Supabase Auth.Asynchronous Processing: The AI analysis task is potentially long-running. To prevent API timeouts and create a responsive user experience, this process must be handled asynchronously. Implement a background job queue using a library like BullMQ backed by a Redis instance. The file upload endpoint will add a job to the queue and immediately return a jobId to the client. The frontend can then use this jobId to poll a separate status endpoint to get real-time updates on the processing progress.3.3 Database and Data Modeling (Supabase/PostgreSQL)Backend-as-a-Service (BaaS): The application will use Supabase for its database, authentication, and storage needs.Rationale for Supabase Mandate: The stringent access control requirements of HIPAA are paramount.5 Supabase is built on PostgreSQL, a relational database that offers native support for Row-Level Security (RLS). RLS is a technically superior mechanism for enforcing HIPAA's "minimum necessary" principle, as it applies security policies directly at the database level. This is a more robust and less error-prone approach than relying solely on application-layer logic, which is often the case with NoSQL databases like Firestore.3RLS Implementation: It is mandatory to enable RLS on all tables that contain or are linked to PHI (e.g., medical_uploads, ai_reports, appointments). The default policy for these tables must be to DENY all access. Then, specific, narrowly-scoped policies must be created to ALLOW access only under specific conditions (e.g., a user can only select their own records where auth.uid() = user_id).Table 1: "InsightMD" Database SchemaThis schema must be implemented precisely in the Supabase PostgreSQL database.Table NameColumn NameData TypeConstraints/NotesusersidUUIDPrimary Key, references auth.users.idfull_nameTEXTNot Nullavatar_urlTEXTNullablecreated_atTIMESTAMPTZNot Null, Default now()medical_uploadsidUUIDPrimary Key, Default gen_random_uuid()user_idUUIDNot Null, Foreign Key to users.idfile_nameTEXTNot Nullfile_pathTEXTNot Null, Path in Supabase Storagefile_typeTEXTNot Null, e.g., 'dicom', 'pdf', 'png'upload_statusTEXTNot Null, 'pending', 'processing', 'complete', 'failed'created_atTIMESTAMPTZNot Null, Default now()ai_reportsidUUIDPrimary Key, Default gen_random_uuid()upload_idUUIDNot Null, Foreign Key to medical_uploads.iduser_idUUIDNot Null, Foreign Key to users.idreport_dataJSONBNot Null, Stores the structured JSON from Geminipdf_urlTEXTNullable, Link to the generated PDF reportcreated_atTIMESTAMPTZNot Null, Default now()specialistsidUUIDPrimary Key, Default gen_random_uuid()nameTEXTNot NullspecialtyTEXTNot Null, IndexedcredentialsTEXTNot Nullconsultation_feeNUMERIC(10, 2)Not NullappointmentsidUUIDPrimary Key, Default gen_random_uuid()user_idUUIDNot Null, Foreign Key to users.idspecialist_idUUIDNot Null, Foreign Key to specialists.idappointment_timeTIMESTAMPTZNot NullstatusTEXTNot Null, 'scheduled', 'completed', 'cancelled'video_session_idTEXTNullable, ID from Zoom SDKaudit_logsidBIGSERIALPrimary Keyuser_idUUIDNullable (for system events)actionTEXTNot Null, e.g., 'LOGIN', 'VIEW_REPORT'target_resource_idUUIDNullableip_addressINETNot NulltimestampTIMESTAMPTZNot Null, Default now()3.4 Gemini API Integration ProtocolSecure Key Management: The Google Gemini API key is highly sensitive. It must be stored as a secure environment variable on the Node.js backend server and loaded at runtime. It must never be hardcoded or exposed to the frontend client.Error Handling: The backend service that communicates with the Gemini API must implement robust error handling. This includes catching API errors, logging them, and returning appropriate HTTP status codes to the client. For transient network issues, implement a retry mechanism with exponential backoff.Structured I/O: All communication with the Gemini API must use a strictly defined JSON structure to ensure reliability and consistency.Table 2: Gemini API Request/Response StructureThis defines the contract for communication between the backend and the Gemini API.ElementTypeDescriptionRequest Bodyimage_dataBase64 StringThe base64-encoded medical image file.mime_typeStringThe MIME type of the image, e.g., 'image/jpeg', 'image/png'.system_promptStringThe role-defining prompt: "You are a helpful radiology assistant..."user_promptStringThe task-specific prompt: "Analyze this image and provide a structured JSON..."Response Body (JSON)summaryStringThe plain-language summary of findings.potential_findingsArray of Objects[{ "finding": "...", "confidence": "High/Medium/Low", "details": "..." }]roi_coordinatesArray of Objects[{ "label": "Finding 1", "x":_,"y":_,"z":_,"width":_,"height":_ }]recommended_specialistStringThe suggested specialist type, e.g., "Cardiologist".disclaimerStringThe mandatory, pre-defined medical disclaimer text.3.5 Mandate for HIPAA Security and PrivacyHIPAA compliance is not a feature; it is a fundamental requirement that must be engineered into every layer of the application. The following safeguards, derived from the HIPAA Security Rule, must be implemented.23 This table translates regulatory requirements into concrete engineering tasks.Table 3: HIPAA Technical Safeguards ImplementationSafeguard (Standard)RequirementImplementation Mandate in "InsightMD"Access ControlUnique User IdentificationRequiredEach user must be assigned a unique ID by the Supabase Auth system (auth.uid()). Anonymous access to PHI is forbidden.Emergency Access ProcedureRequiredA procedure must be documented in the README.md file detailing how a designated security officer (e.g., a database admin) can gain emergency access to data via the Supabase dashboard to assist a user in a crisis.Automatic LogoffAddressableThis is deemed reasonable and appropriate. The frontend must implement an idle timer that automatically logs the user out and clears session data after 15 minutes of inactivity.Encryption and DecryptionAddressableThis is deemed reasonable and appropriate and is mandatory. Data must be encrypted both in transit (TLS 1.3) and at rest (Supabase's default storage and database encryption).Audit ControlsRequiredA logging middleware must be implemented in the Node.js backend. It will automatically record all events involving access to PHI (e.g., VIEW_REPORT, UPLOAD_FILE, LOGIN) into the audit_logs table. The log must capture who, what, when, and from where.IntegrityRequiredThe backend must implement controls to ensure PHI is not improperly altered or destroyed. This includes using database constraints (foreign keys, NOT NULL) and performing checksum validation on file uploads and downloads to detect corruption.AuthenticationRequiredThe system must verify that a person is who they claim to be. This is achieved through Supabase Auth's strong password requirements and the mandated implementation of MFA.Transmission SecurityRequiredAll data transmitted over any network must be encrypted. This is ensured by enforcing HTTPS (TLS 1.3) for all communication between the client, backend, and third-party APIs (Supabase, Gemini, Zoom).Section 4: Hackathon and Presentation Optimization StrategyThe final product must not only be functional but also optimized for a high-impact, short-form presentation.4.1 MVP Focus and Demo FlowThe Golden Path: The 3-minute demonstration must focus on the most compelling user journey: User Login -> View Dashboard -> Select Pre-Uploaded MRI Scan -> Interact with the 3D Model and see the AI-highlighted ROI -> View the Impressive AI-Generated Report. The specialist matching and video call features are important secondary features that should be functional but are not the primary focus of the short demo.4.2 Polished User Interface and VisualsAesthetics and Feel: The UI must be exceptionally clean, modern, and professional. Use smooth page transitions and loading animations (e.g., skeleton loaders) to make the application feel fast and responsive, particularly while the user is waiting for backend processing to complete.Data Visualization: The dashboard and AI report pages should utilize simple charts and graphs (e.g., using a library like Recharts) to present information in a visually engaging and easily digestible format.4.3 Pre-populated Demonstration DataTo guarantee a flawless and impressive live demonstration, it is mandatory to avoid reliance on live file uploads and real-time AI processing, which can be slow and unpredictable.Mandate: Create a database seeding script (e.g., prisma/seed.ts or a custom script).Content: This script must populate the database for a "perfect demo user" account. This user's account must be pre-loaded with:At least one high-quality, anonymized DICOM series (e.g., a brain MRI) already present in Supabase Storage and linked in the medical_uploads table.A corresponding, pre-generated ai_reports entry that is detailed, accurate, and visually impressive, with defined roi_coordinates.A sample blood test PDF upload and its corresponding AI-generated text analysis report.A list of several sample specialists in the specialists table so the matching feature can be demonstrated.Purpose: This pre-seeded data ensures that the presenter can log in and immediately showcase the application's most powerful features without any waiting or risk of runtime errors, maximizing the impact of the presentation.Conclusion: Final Build and Cohesion DirectiveSynthesize all preceding sections into a single, cohesive, and fully functional "InsightMD" application. Ensure all frontend and backend components are correctly interconnected, the code is meticulously documented with comments explaining complex logic, and all security and HIPAA compliance mandates are strictly implemented and verifiable. The final generated output should be a zip archive containing the complete, organized source code for the Next.js frontend and the Node.js backend, the database seeding script, and the comprehensive README.md file. Execute this master plan.